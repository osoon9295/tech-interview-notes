# 제로 런타임 css

**제로 런타임 css란 무엇인가요?**

### 제로 런타임 css란?

- 브라우저에서 자바스크립트 런타임 시점에 스타일을 계산하거나 생성하지 않는 CSS 방식
- 빌드 타임에 모든 CSS를 생성
- 브라우저에서는 단순히 CSS 파일만 읽고 적용하도록 하는 전략

### 기존 방식 vs 제로 런타임 방식

- 런타임 CSS 방식 (예: Styled-components, Emotion 기본 모드)

  - 동작 원리
    1. 자바스크립트가 실행되면서 스타일 객체를 해석
    2. 브라우저 DOM에 `<style>` 태그를 동적으로 삽입
  - 특징
    - 동적 props, 조건부 스타일링이 자유로움
    - 그러나 JS 실행 전까지 스타일이 적용되지 않음
    - 런타임 오버헤드 존재 -> 성능 저하 가능
  - 예시

  ```tsx
  const Button = styled.button`
    background: ${(props) => (props.primary ? "blue" : "gray")};
  `;
  ```

- 제로 런타임 CSS 방식 (예: Tailwind CSS, Vanilla Extract, Linaria)

  - 동작원리
    1. 빌드 시점(webpack,Vite,SWC 등)에서 모든 스타일을 추출하여, `.css`파일로 만듦
    2. 브라우저에서는 미리 생성된 CSS를 바로 로드
  - 특징
    - 런타임 오버헤드 없음 -> 빠른 렌더링
    - SEO/SSR 친화적 (HTML에 스타일 바로 적용)
    - 스타일링 로직이 JS 실행과 무관 -> JS 비활성화 상태에서도 디자인 유지 가능
    - 단, 런타임 props 기반 스타일링이 제한됨(빌드 시점에 결정 불가한 값은 처리 어려움)
  - 예시

  ```tsx
  export const button = style({
    background: "blue",
  });
  ```

  <br>

---

### Emotion 이란?

- CSS-in-JS 방식의 스타일링 라이브러리 중 하나
- JavaScript 프로젝트에서 JS 파일 안에서 CSS를 작성할 수 있게 해줌
- `styled-components`와 유사
- 성능 최적화와 유연성에 강점

### Emotion 특징

1. CSS-in-JS
   - JavaScript/TypeScript 코드 안에서 CSS 작성 가능
   - CSS 클래스 이름이 자동으로 해시 처리되어 충돌 방지
2. 두 가지 사용 방식 지원

   - Styled Components API

   ```tsx
   import styled from "@emotion/styled";

   const Button = styled.button`
     background: hotpink;
     &:hover {
       background: deeppink;
     }
   `;
   ```

   - css props 방식 (Babel 설정 필요)

   ```tsx
   /** @jsxImportSource @emotion/react */
   import { css } from "@emotion/react";

   const style = css`
     color: red;
     font-size: 20px;
   `;

   <div css={style}>Hello</div>;
   ```

3. 동적 스타일링 지원

   - props나 state 값에 따라 런타임 시점에 스타일 결정 가능

   ```tsx
   const Button = styled.button<{ primary?: boolean }>`
     background: ${({ primary }) => (primary ? "blue" : "gray")};
   `;
   ```

4. SSR(Server Side Rendering) 지원

   - Next.js 같은 SSR 환경에서 스타일이 깨지지 않도록 처리 가능
   - `@emotion/server`를 이용해 HTML에 스타일 태그 주입

5. Zero-runtime CSS 지원 가능
   - `@emotion/babel-plugin`과 함께 사용하면 빌드 타임에 CSS를 추출하여 제로 런타임 CSS처럼 동작하게 최적화 가능

### Emotion의 장점

- 가벼움(비슷한 기능 대비 번들 크기 작음)
- 동적 스타일과 조건부 스타일링이 간단
- TypeScript 친화적
- SSR/CSR 모두 지원
- Tailwind처럼 Utility Class를 쓰지 않고도 구조적 스타일링 가능

### Emotion의 단점

- 기본 모드는 런타임 CSS이므로 JS 실행 전 스타일 적용이 안 될 수 있음
- 빌드 타임 추출 기능을 쓰려면 Babel 설정이 필요
- 스타일 로직이 컴포넌트와 밀접해져서 CSS 분리 관리가 어려울 수 있음

### 런타임 오버헤드란?

- CSS-in-JS가 브라우저에서 JS가 실행될 때 스타일을 만들고 `<style>` 태그에 규칙을 삽입하는 과정에서 생기는 추가작업
- 계산, 메모리, 네트워크, 브라우저 재계산 등등

### 오버헤드가 생기는 구체적 지점

1. 파싱&평가

   - 템플릿 리터럴/스타일 객체를 JS로 해석
   - 빌드가 아닌 렌더 시점에 이 코드가 돌기 때문에 첫 렌더 전에 해야 할 일 증가

2. 클레스네임 해싱
   - 규칙 충돌 방지를 위해 스타일 내용을 해시 -> 고유 클래스명을 생성 -해싱 자체가 크지 않지만, 컴포넌트가 많이 마운트될수록 누적
3. CSS 직렬화&`<style>`삽입
   - JS 객체/문자열을 표준 CSS로 직렬화하고, DOM의 `<style>`에 rule 추가
   - rule 추가는 스타일 재계산을 유발(브라우저가 새 규칙 반영)
4. 캐시 관리
   - 같은 스타일을 매번 만들지 않도록 런타임 캐시를 유지
   - 캐시 조회/적재에도 CPU,메모리가 조금씩 사용됨
   - props 값이 다양하면 캐시 히트율이 낮아져 규칙이 계속 늘어날 수 있음
5. SSR Hydration비용
   - SSR 시 서버가 만든 `<style>`을 클라언트가 재결합(재사용)해야 함
   - 이때 규칙 매칭, 동기화 작업이 추가
   - 미스 매치가 있으면 중복 규칙 삽입/정리가 또 발생
6. 동적 props -> 규칙 폭증 위험
   - `color={user.favoriteColor}`처럼 값이 무한히 다양하면, 매 값마다 새 클래스가 생길 수 있음
   - 리스트/테이블처럼 대량 렌더링에서 규칙 수 증가 + 스타일 재계산이 체감
7. 메모리 & GC 압력
   - 생성된 규칙과 캐시가 메모리를 잡아먹고, 수시로 만들어졌다가 사라지면 GC가 자주 돌게됨
8. 번들 크기 증가(네트워크)

   - 런타임 엔진(해시/직렬화/캐시 코드)이 앱 JS에 포함

9. 브라우저 스타일/레이아웃 작업
   - `<style>`이 바뀌면 브라우저는 스타일 재계산 -> 필요 시 레이아웃/페인트
   - 라이브러리들이 최대한 배치/중복 방지 최적화를 하지만, 규모가 커지면 비용 상승
